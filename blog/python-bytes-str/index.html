<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="lang">
  <head>
    <title data-vue-tag="true">(Python3) Sequences of Characters - Gimmeyoon</title><meta data-vue-tag="true" charset="utf-8"><meta data-vue-tag="true" name="generator" content="Gridsome v0.6.9"><meta data-vue-tag="true" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="true" data-key="format-detection" name="format-detection" content="telephone=no"><noscript data-vue-tag="true" ><style>.g-image--loading{display:none;}</style></noscript><link rel="preload" href="/assets/css/0.styles.2e6c3f99.css" as="style"><link rel="preload" href="/assets/js/app.68cc814d.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--blog-vue.2d008bb1.js" as="script"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.cd23979d.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.1f206ee1.js"><link rel="prefetch" href="/assets/js/page--src--pages--info-vue.0e5c2ed9.js"><link rel="stylesheet" href="/assets/css/0.styles.2e6c3f99.css">
  </head>
  <body data-vue-tag="">
    <div data-server-rendered="true" id="app" class="layout"><header class="header"><nav class="nav"><a href="/"><h1>Gimmeyoon</h1></a><div><h1><a href="/info">
                    About
                </a></h1></div></nav></header><div class="content"><article class="blog"><div class="blog__info"><h1>(Python3) Sequences of Characters</h1><h3>December 07 2019</h3></div><div class="blog__body"><p>Python3에서 Unicode를 어떻게 다루는지 공부했던 것들을 기록해본다.</p>
<h1 id="abstract"><a href="#abstract" aria-hidden="true"><span class="icon icon-link"></span></a>Abstract</h1>
<p>다국어 프로그램을 다루기 위해서는 unicode에 대한 이해가 필수적이다.
(ASCII -> ANSI -> Unicode)
사실 네이버로 이직한 이후로는 쭉 백엔드 웹서버 개발만 하기 때문에
지금은 unicode를 고려하고 구현할일이 없다.
옛날 TmaxOS 개발에 참여했을 당시에는 나라별로 미리 정의된 다른 메세지를
보여주어야 했었는데, 그때 유심히 본 기억이 있다.
아무튼 Python3에서 unicode와 관련한 <strong>가장 중요하고
간단한 사실은 <code>str</code>은 unicode를 저장한다는 점이다.</strong></p>
<h1 id="unicode"><a href="#unicode" aria-hidden="true"><span class="icon icon-link"></span></a>Unicode</h1>
<p>Unicode standard는 문자를 0x0부터 0x10FFFF 사이의 code point들로 표현하는
방법을 정의한다. unicode를 다루는 포스트에서 110만(0x10FFFF=1,114,111)이라는
숫자가 자주 등장하는 이유가 여기있다. 즉, Unicode는 sequence of code points이며
각 code point는 sequence of byte로 <strong>encoding</strong>된다.
아래의 예는 Unicode 문자열 "hello"를 UTF-8로 encoding하는 과정을 보여준다.
<img class="g-image g-image--lazy g-image--loading" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1209 676' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-5'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-5)' width='1209' height='676' xlink:href='data:image/png%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAkCAIAAAC2bqvFAAAACXBIWXMAAAsSAAALEgHS3X78AAAGDklEQVRYw%2b1YWzNjWRT2MzzhQXlQSrm8uD2oorzw6o0XRfHCC1P%2bAapb13R5IukhzNDGrZR0DyZENIIwiE4EQ1wiV4lELuRuvpydnDmS43RX0Houu06dWmfvtdfaa6%2b91rf2Sbh73hZ8Zvl3Cc%2by6mDQ67QGfZ7wh98X8HtA3AUD37sBWC3eHptBI/lJu/yzfu1X3covurVh7ZJAJx20qCT/EA9gwx2Xnmuj26pzmTVumx6E26r3OixRnAGqPaUB2EKfzxf2vN9/9923hIdOAjkMHA0756MaKyfpdDjs6%2bvrPp%2bXdMUyqNVqpVJJf8Y2bCKHlnsGEI7z8/Oqqqrb29vNzc26ujri3y8aw2oe3lKpNCcnB9JihRD3trS01NfXgyBuf5QHiEqVSpWUlHR6ejo8PJyZmclqAOkET3V1dUNDw%2bXl5UM8q6ur%2bfn5brf7IQNaW1ubmppYDSASxGJxSUkJ7PR6vaxbGW0AfJqYmAitaWlpBQUFrAYQ3ZWVlWVlZbm5uc3NzfgkCmINyMvL4zagsbEx1gDCfHNzk56eLhAISktLu7q66FlcBuzv7ycnJx8eHg4ODmZlZXF4oLCwsLy8vK2tbWJiIlY04VlZWYEbnU4nxxGqqal5yACTyZSamqrVamtra2Eqq6OiDTg%2bPi4uLobpS0tLWB%2bHAUKhENtfUVGxvb1Nd0at4OrqKjs7e3x8PNZC8jk5OZmRkWGz2R7S0tHRkZKSUlRUhOCM1cKShSDXbrfjDb87HA7uALJYLDhysJYj0CHN5XJxCCHqOJBRp9ORlbCqiB/IaMSI2fhQyRAiyBMZCL9JQREZ8ng8HCmSXjRHWn8UEr97x%2b/p6WE94pEyLsio54J3jHXQUd7R0a5QfGY9Hs9YSpB1fPgg7Onp9lBJxu92mndnUfCYtoUW5TxKIP3ae9vx%2bqX8N3SCNit%2bR6dxW2hYHzHIRlHtUSF31N7ednJyEh/axG8A2a3FxcWBgYGwiwMBp05lP9t2aD7bz%2bXXJ5t4bi2aEK3euFbLbq%2b0N0Y1Ph2h0S2vKxS4Vqv17dsfEevf1AA6SfN4PXw%2bH6Ech3rCPzcn6ux8tbW19WQGBO435AdWucQDEolkfn4OPPiEB4gj7iIPZocev88ffvwUT4AK8QDJPEhio6MjZrOZNQYov95rXEgc30GKb9u4U1k8HiDrwGEAPKECGxkZ6e/vn5qa6u7uXltbY24P4QQ2gQ0eAAOgfmhoCDTNRngwcXp6en5%2bnsfjjY2NAdrxSY9iukgkWlhYwCGEOkiAuigtmAU8BRsirbe3F7pQYkb56p4HsBnwqV6vR6EG4uLi4uDgIKpWIwQYgC9g%2bJNqKD0wi5m28TYYDGdnZygEgO7gB5tGo6FHjUYjGUU/stDR0RE%2bowxAPxigBQTYUOYQTGS6/VluZC95oSHHmjtuaLbVValMJkM6IlP%2bBl0Ka0kSoEI5nA%2bYro%2bUXkcSyQLxXmxBEZVOWDPKo4AMh/L161cPIPFXIYlMtt7a%2bsPOzs63RuJItbzc3y9gmhTw3gLLrvYXHZpdp/7AeaFw6Q98N9d4HBrQhz6XLej3MiLBACCLD0keBWRE2cePQoGgL1KkUcWZ3aSXDpoVIuvhivGPSdPWpEbCC/1ckQ5qxN0oJdTCDpfpmPpzEdoCxC4M0Om0L4DEqLf5fF5fX%2b%2bX948xhJIJIEb7EEj85k2nXL7zNAaQrSUBStOxcUz/ccHOIffR0cZkC0Z6IkMUHYlCOuhx39/bUxKa1suEYeYa6PbsP7ZeII0Ss1BU4X4I8MNddmNjA8lhDj4WiVQqFfPoo3RZXl4GeCkUChSkwGAQ6AE/fbVHZsQQ0BB4jKIfGARMBCqjk1w1oQWdcrn806dPe3t7GAUqgybXS8q9OjADwogEwgOlIJjVxz0DsGilUokFYSYs2d3dBfjPzMzQ/57ouzaWS8AVzFAMuXgzRQNBsRq8oR5VA04ajJmdnRWLxfQWoAdTwAYCC8VOQRoKbCIBAIxlALCJBALnkANdzD8g/y4k/vogpnkCjGC9F8RsIUj/yo3SEqX3PxnE/xvwYu0vIJS8E/Gl3mMAAAAASUVORK5CYII=' /%3e%3c/svg%3e" width="1209" data-srcset="/assets/static/unicode-encoding.82a2fbd.ff5856f.png 480w, /assets/static/unicode-encoding.cbab2cf.ff5856f.png 1024w" data-sizes="(max-width: 1209px) 100vw, 1209px" data-src="/assets/static/unicode-encoding.cbab2cf.ff5856f.png"><noscript><img class="g-image g-image--lazy g-image--loaded" src="/assets/static/unicode-encoding.cbab2cf.ff5856f.png" width="1209"></noscript></p>
<h1 id="in-python"><a href="#in-python" aria-hidden="true"><span class="icon icon-link"></span></a>In Python</h1>
<p>Python3에서 문자열(sequence of characters)을 표현하는 방법은
<code>str</code>와 <code>bytes</code> 두가지이다. (참고. Python2는 <code>unicode</code>와 <code>str</code>)</p>
<ul>
<li>
<p>Two types that reprsent sequences of characters in Python3</p>
<ul>
<li><code>str</code>: unicode chracters를 저장</li>
<li><code>bytes</code>: raw 8-bit을 저장</li>
</ul>
</li>
</ul>
<p>Python3의 <code>str</code>은 unicode를 저장하는 용도로 사용된다.
따라서 unicode 문자열을 만드는 방법은 아주 쉽다.
single/double/triple-quote로 정의한 string literal은 모두 unicode string이다.
하나의 unicode character를 만들고 싶다면, <code>chr()</code>을 사용하면 되고, 해당하는
code point는 <code>ord()</code>를 통해 구할 수 있다.
또한, Python3에서는 소스코드의 기본 인코딩이 UTF-8이기 때문에 별도의 명시없이
unicode로 문자열을 정의할 수 있다. Identifier에도 unicode를 사용할 수
있기 때문에 아래의 코드도 문제없이 실행된다.</p>
<pre class="language-sh"><code class="language-sh">Type "help", "copyright", "credits" or "license" for more information.
>>> 주호 = 'jooho'
>>> print(주호)
jooho</code></pre>
<p><code>bytes</code>는 unicode가 아닌 1byte로 표현되는 문자들을 저장하기위한
용도로 사용된다. (Python2와 달리) <code>bytes</code>라는 이름이 "byte들"을 의미한다는
점에서 이해하기 쉽다. <code>str</code>과 <code>bytes</code>를 다룰 때는 encoding/decoding을
주의해서 사용해야한다.</p>
<ul>
<li>Should not assume anything about character encodings</li>
<li>
<p>Two common situations in Python code</p>
<ul>
<li>You want to operate on raw 8-bit values that are UTF-8 encoded characters</li>
<li>You want to operate on Unicode characters that have no specific encoding</li>
</ul>
</li>
</ul>
<p>따라서 아래와 같이 <code>str</code>/<code>bytes</code> 모두를 받아서 실수없이 <code>str</code>/<code>bytes</code>로
바꿔주는 helper 함수가 필요할 수도 있다.</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">to_str</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">,</span> <span class="token builtin">bytes</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> bytes_or_str<span class="token punctuation">.</span>decode<span class="token punctuation">(</span>‘utf<span class="token operator">-</span><span class="token number">8</span>’<span class="token punctuation">)</span>
  <span class="token keyword">else</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> bytes_or_str
  <span class="token keyword">return</span> value <span class="token comment"># Instance of str</span>

<span class="token keyword">def</span> <span class="token function">to_bytes</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>bytes_or_str<span class="token punctuation">,</span> <span class="token builtin">str</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> bytes_or_str<span class="token punctuation">.</span>encode<span class="token punctuation">(</span>‘utf<span class="token operator">-</span><span class="token number">8</span>’<span class="token punctuation">)</span>
  <span class="token keyword">else</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> bytes_or_str
  <span class="token keyword">return</span> value <span class="token comment"># Instance of bytes</span></code></pre>
<h2 id="problems-in-python2"><a href="#problems-in-python2" aria-hidden="true"><span class="icon icon-link"></span></a>Problems in Python2</h2>
<p>(곧 Python2는 deprecated되지만)
Unicode와 관련된 Python2에의 첫번째 문제점은
ASCII 문자열이 저장된 <code>str</code>의 경우, encode() 결과도 여전히 <code>str</code>이라는 점이다.
따라서 ASCII 문자열만이 정상동작하고, 그렇지 않은 경우
예상과 달리 동작하는 함수를 만들 수 있다. Python3의 경우 empty string 조차도
<code>str</code>과 <code>bytes</code>는 전혀 다른 type이다.</p>
<p>두번째 문제점은 file operation들이 기본 binary encoding이라는 점이다.
따라서 Unicode로 작성된 파일을 읽고/쓰는데 불편했지만, Python3에서는
기본 UTF-8 encoding이 적용된다. Python3에서는 binary로 읽고/쓰기 위해서는
'rb', 'wb'로 mode를 명시해주어야한다.</p>
<h1 id="summary"><a href="#summary" aria-hidden="true"><span class="icon icon-link"></span></a>Summary</h1>
<ul>
<li>
<p>Python 3</p>
<ul>
<li><code>bytes</code>: sequences of 8-bit values.</li>
<li><code>str</code>: sequences of Unicode characters.</li>
<li><code>bytes</code> != <code>str</code></li>
</ul>
</li>
<li>
<p>Python 2</p>
<ul>
<li><code>str</code> contains sequences of 8-bit values.</li>
<li><code>unicode</code> contains sequences of Unicode characters.</li>
<li><code>str</code> == <code>unicode</code> if the <code>str</code> only contains 7-bit ASCII characters.</li>
</ul>
</li>
<li>Binary data to/from a file: binary mode ('rb' or 'wb').</li>
</ul>
<h1 id="reference"><a href="#reference" aria-hidden="true"><span class="icon icon-link"></span></a>Reference</h1>
<ul>
<li><a href="https://docs.python.org/3/howto/unicode.html" target="_blank" rel="nofollow noopener noreferrer">python.org</a></li>
<li>Effective Python</li>
</ul>
</div><div class="blog__footer"><h2>Written By: Jooho Yoon</h2><a href="/blog/initial-post"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" viewBox="0 0 26 26" enableBackground="new 0 0 26 26"><path d="M23.021,12.294l-8.714-8.715l-1.414,1.414l7.007,7.008H2.687v2h17.213l-7.007,7.006l1.414,1.414l8.714-8.713  C23.411,13.317,23.411,12.685,23.021,12.294z"></path></svg></a></div></article></div></div>
    <script>window.__INITIAL_STATE__={"data":{"post":{"title":"(Python3) Sequences of Characters","date":"December 07 2019","author":"Jooho Yoon","content":"\u003Cp\u003EPython3에서 Unicode를 어떻게 다루는지 공부했던 것들을 기록해본다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"abstract\"\u003E\u003Ca href=\"#abstract\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EAbstract\u003C\u002Fh1\u003E\n\u003Cp\u003E다국어 프로그램을 다루기 위해서는 unicode에 대한 이해가 필수적이다.\n(ASCII -\u003E ANSI -\u003E Unicode)\n사실 네이버로 이직한 이후로는 쭉 백엔드 웹서버 개발만 하기 때문에\n지금은 unicode를 고려하고 구현할일이 없다.\n옛날 TmaxOS 개발에 참여했을 당시에는 나라별로 미리 정의된 다른 메세지를\n보여주어야 했었는데, 그때 유심히 본 기억이 있다.\n아무튼 Python3에서 unicode와 관련한 \u003Cstrong\u003E가장 중요하고\n간단한 사실은 \u003Ccode\u003Estr\u003C\u002Fcode\u003E은 unicode를 저장한다는 점이다.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Ch1 id=\"unicode\"\u003E\u003Ca href=\"#unicode\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EUnicode\u003C\u002Fh1\u003E\n\u003Cp\u003EUnicode standard는 문자를 0x0부터 0x10FFFF 사이의 code point들로 표현하는\n방법을 정의한다. unicode를 다루는 포스트에서 110만(0x10FFFF=1,114,111)이라는\n숫자가 자주 등장하는 이유가 여기있다. 즉, Unicode는 sequence of code points이며\n각 code point는 sequence of byte로 \u003Cstrong\u003Eencoding\u003C\u002Fstrong\u003E된다.\n아래의 예는 Unicode 문자열 \"hello\"를 UTF-8로 encoding하는 과정을 보여준다.\n\u003Cimg class=\"g-image g-image--lazy g-image--loading\" src=\"data:image\u002Fsvg+xml,%3csvg fill='none' viewBox='0 0 1209 676' xmlns='http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg' xmlns:xlink='http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-5'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='40'\u002F%3e%3c\u002Ffilter%3e%3c\u002Fdefs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-5)' width='1209' height='676' xlink:href='data:image\u002Fpng%3bbase64%2ciVBORw0KGgoAAAANSUhEUgAAAEAAAAAkCAIAAAC2bqvFAAAACXBIWXMAAAsSAAALEgHS3X78AAAGDklEQVRYw%2b1YWzNjWRT2MzzhQXlQSrm8uD2oorzw6o0XRfHCC1P%2bAapb13R5IukhzNDGrZR0DyZENIIwiE4EQ1wiV4lELuRuvpydnDmS43RX0Houu06dWmfvtdfaa6%2b91rf2Sbh73hZ8Zvl3Cc%2by6mDQ67QGfZ7wh98X8HtA3AUD37sBWC3eHptBI\u002FlJu\u002Fyzfu1X3covurVh7ZJAJx20qCT\u002FEA9gwx2Xnmuj26pzmTVumx6E26r3OixRnAGqPaUB2EKfzxf2vN9\u002F9923hIdOAjkMHA0756MaKyfpdDjs6%2bvrPp%2bXdMUyqNVqpVJJf8Y2bCKHlnsGEI7z8\u002FOqqqrb29vNzc26ujri3y8aw2oe3lKpNCcnB9JihRD3trS01NfXgyBuf5QHiEqVSpWUlHR6ejo8PJyZmclqAOkET3V1dUNDw%2bXl5UM8q6ur%2bfn5brf7IQNaW1ubmppYDSASxGJxSUkJ7PR6vaxbGW0AfJqYmAitaWlpBQUFrAYQ3ZWVlWVlZbm5uc3NzfgkCmINyMvL4zagsbEx1gDCfHNzk56eLhAISktLu7q66FlcBuzv7ycnJx8eHg4ODmZlZXF4oLCwsLy8vK2tbWJiIlY04VlZWYEbnU4nxxGqqal5yACTyZSamqrVamtra2Eqq6OiDTg%2bPi4uLobpS0tLWB%2bHAUKhENtfUVGxvb1Nd0at4OrqKjs7e3x8PNZC8jk5OZmRkWGz2R7S0tHRkZKSUlRUhOCM1cKShSDXbrfjDb87HA7uALJYLDhysJYj0CHN5XJxCCHqOJBRp9ORlbCqiB\u002FIaMSI2fhQyRAiyBMZCL9JQREZ8ng8HCmSXjRHWn8UEr97x%2b\u002Fp6WE94pEyLsio54J3jHXQUd7R0a5QfGY9Hs9YSpB1fPgg7Onp9lBJxu92mndnUfCYtoUW5TxKIP3ae9vx%2bqX8N3SCNit%2bR6dxW2hYHzHIRlHtUSF31N7ednJyEh\u002FaxG8A2a3FxcWBgYGwiwMBp05lP9t2aD7bz%2bXXJ5t4bi2aEK3euFbLbq%2b0N0Y1Ph2h0S2vKxS4Vqv17dsfEevf1AA6SfN4PXw%2bH6Ech3rCPzcn6ux8tbW19WQGBO435AdWucQDEolkfn4OPPiEB4gj7iIPZocev88ffvwUT4AK8QDJPEhio6MjZrOZNQYov95rXEgc30GKb9u4U1k8HiDrwGEAPKECGxkZ6e\u002Fvn5qa6u7uXltbY24P4QQ2gQ0eAAOgfmhoCDTNRngwcXp6en5%2bnsfjjY2NAdrxSY9iukgkWlhYwCGEOkiAuigtmAU8BRsirbe3F7pQYkb56p4HsBnwqV6vR6EG4uLi4uDgIKpWIwQYgC9g%2bJNqKD0wi5m28TYYDGdnZygEgO7gB5tGo6FHjUYjGUU\u002FstDR0RE%2bowxAPxigBQTYUOYQTGS6\u002FVluZC95oSHHmjtuaLbVValMJkM6IlP%2bBl0Ka0kSoEI5nA%2bYro%2bUXkcSyQLxXmxBEZVOWDPKo4AMh\u002FL161cPIPFXIYlMtt7a%2bsPOzs63RuJItbzc3y9gmhTw3gLLrvYXHZpdp\u002F7AeaFw6Q98N9d4HBrQhz6XLej3MiLBACCLD0keBWRE2cePQoGgL1KkUcWZ3aSXDpoVIuvhivGPSdPWpEbCC\u002F1ckQ5qxN0oJdTCDpfpmPpzEdoCxC4M0Om0L4DEqLf5fF5fX%2b%2bX948xhJIJIEb7EEj85k2nXL7zNAaQrSUBStOxcUz\u002FccHOIffR0cZkC0Z6IkMUHYlCOuhx39\u002FbUxKa1suEYeYa6PbsP7ZeII0Ss1BU4X4I8MNddmNjA8lhDj4WiVQqFfPoo3RZXl4GeCkUChSkwGAQ6AE\u002FfbVHZsQQ0BB4jKIfGARMBCqjk1w1oQWdcrn806dPe3t7GAUqgybXS8q9OjADwogEwgOlIJjVxz0DsGilUokFYSYs2d3dBfjPzMzQ\u002F57ouzaWS8AVzFAMuXgzRQNBsRq8oR5VA04ajJmdnRWLxfQWoAdTwAYCC8VOQRoKbCIBAIxlALCJBALnkANdzD8g\u002Fy4k\u002FvogpnkCjGC9F8RsIUj\u002Fyo3SEqX3PxnE\u002FxvwYu0vIJS8E\u002FGl3mMAAAAASUVORK5CYII=' \u002F%3e%3c\u002Fsvg%3e\" width=\"1209\" data-srcset=\"\u002Fassets\u002Fstatic\u002Funicode-encoding.82a2fbd.ff5856f.png 480w, \u002Fassets\u002Fstatic\u002Funicode-encoding.cbab2cf.ff5856f.png 1024w\" data-sizes=\"(max-width: 1209px) 100vw, 1209px\" data-src=\"\u002Fassets\u002Fstatic\u002Funicode-encoding.cbab2cf.ff5856f.png\"\u003E\u003Cnoscript\u003E\u003Cimg class=\"g-image g-image--lazy g-image--loaded\" src=\"\u002Fassets\u002Fstatic\u002Funicode-encoding.cbab2cf.ff5856f.png\" width=\"1209\"\u003E\u003C\u002Fnoscript\u003E\u003C\u002Fp\u003E\n\u003Ch1 id=\"in-python\"\u003E\u003Ca href=\"#in-python\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EIn Python\u003C\u002Fh1\u003E\n\u003Cp\u003EPython3에서 문자열(sequence of characters)을 표현하는 방법은\n\u003Ccode\u003Estr\u003C\u002Fcode\u003E와 \u003Ccode\u003Ebytes\u003C\u002Fcode\u003E 두가지이다. (참고. Python2는 \u003Ccode\u003Eunicode\u003C\u002Fcode\u003E와 \u003Ccode\u003Estr\u003C\u002Fcode\u003E)\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003ETwo types that reprsent sequences of characters in Python3\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003E: unicode chracters를 저장\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ebytes\u003C\u002Fcode\u003E: raw 8-bit을 저장\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EPython3의 \u003Ccode\u003Estr\u003C\u002Fcode\u003E은 unicode를 저장하는 용도로 사용된다.\n따라서 unicode 문자열을 만드는 방법은 아주 쉽다.\nsingle\u002Fdouble\u002Ftriple-quote로 정의한 string literal은 모두 unicode string이다.\n하나의 unicode character를 만들고 싶다면, \u003Ccode\u003Echr()\u003C\u002Fcode\u003E을 사용하면 되고, 해당하는\ncode point는 \u003Ccode\u003Eord()\u003C\u002Fcode\u003E를 통해 구할 수 있다.\n또한, Python3에서는 소스코드의 기본 인코딩이 UTF-8이기 때문에 별도의 명시없이\nunicode로 문자열을 정의할 수 있다. Identifier에도 unicode를 사용할 수\n있기 때문에 아래의 코드도 문제없이 실행된다.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-sh\"\u003E\u003Ccode class=\"language-sh\"\u003EType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n\u003E\u003E\u003E 주호 = 'jooho'\n\u003E\u003E\u003E print(주호)\njooho\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Ccode\u003Ebytes\u003C\u002Fcode\u003E는 unicode가 아닌 1byte로 표현되는 문자들을 저장하기위한\n용도로 사용된다. (Python2와 달리) \u003Ccode\u003Ebytes\u003C\u002Fcode\u003E라는 이름이 \"byte들\"을 의미한다는\n점에서 이해하기 쉽다. \u003Ccode\u003Estr\u003C\u002Fcode\u003E과 \u003Ccode\u003Ebytes\u003C\u002Fcode\u003E를 다룰 때는 encoding\u002Fdecoding을\n주의해서 사용해야한다.\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EShould not assume anything about character encodings\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003ETwo common situations in Python code\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EYou want to operate on raw 8-bit values that are UTF-8 encoded characters\u003C\u002Fli\u003E\n\u003Cli\u003EYou want to operate on Unicode characters that have no specific encoding\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E따라서 아래와 같이 \u003Ccode\u003Estr\u003C\u002Fcode\u003E\u002F\u003Ccode\u003Ebytes\u003C\u002Fcode\u003E 모두를 받아서 실수없이 \u003Ccode\u003Estr\u003C\u002Fcode\u003E\u002F\u003Ccode\u003Ebytes\u003C\u002Fcode\u003E로\n바꿔주는 helper 함수가 필요할 수도 있다.\u003C\u002Fp\u003E\n\u003Cpre class=\"language-python\"\u003E\u003Ccode class=\"language-python\"\u003E\u003Cspan class=\"token keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Eto_str\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Ebytes_or_str\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"token builtin\"\u003Eisinstance\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Ebytes_or_str\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token builtin\"\u003Ebytes\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E:\u003C\u002Fspan\u003E\n    value \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E bytes_or_str\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003Edecode\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E‘utf\u003Cspan class=\"token operator\"\u003E-\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E8\u003C\u002Fspan\u003E’\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Eelse\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E:\u003C\u002Fspan\u003E\n    value \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E bytes_or_str\n  \u003Cspan class=\"token keyword\"\u003Ereturn\u003C\u002Fspan\u003E value \u003Cspan class=\"token comment\"\u003E# Instance of str\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"token keyword\"\u003Edef\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Eto_bytes\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Ebytes_or_str\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E:\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Eif\u003C\u002Fspan\u003E \u003Cspan class=\"token builtin\"\u003Eisinstance\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003Ebytes_or_str\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E \u003Cspan class=\"token builtin\"\u003Estr\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E:\u003C\u002Fspan\u003E\n    value \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E bytes_or_str\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003Eencode\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E‘utf\u003Cspan class=\"token operator\"\u003E-\u003C\u002Fspan\u003E\u003Cspan class=\"token number\"\u003E8\u003C\u002Fspan\u003E’\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Eelse\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E:\u003C\u002Fspan\u003E\n    value \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E bytes_or_str\n  \u003Cspan class=\"token keyword\"\u003Ereturn\u003C\u002Fspan\u003E value \u003Cspan class=\"token comment\"\u003E# Instance of bytes\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"problems-in-python2\"\u003E\u003Ca href=\"#problems-in-python2\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EProblems in Python2\u003C\u002Fh2\u003E\n\u003Cp\u003E(곧 Python2는 deprecated되지만)\nUnicode와 관련된 Python2에의 첫번째 문제점은\nASCII 문자열이 저장된 \u003Ccode\u003Estr\u003C\u002Fcode\u003E의 경우, encode() 결과도 여전히 \u003Ccode\u003Estr\u003C\u002Fcode\u003E이라는 점이다.\n따라서 ASCII 문자열만이 정상동작하고, 그렇지 않은 경우\n예상과 달리 동작하는 함수를 만들 수 있다. Python3의 경우 empty string 조차도\n\u003Ccode\u003Estr\u003C\u002Fcode\u003E과 \u003Ccode\u003Ebytes\u003C\u002Fcode\u003E는 전혀 다른 type이다.\u003C\u002Fp\u003E\n\u003Cp\u003E두번째 문제점은 file operation들이 기본 binary encoding이라는 점이다.\n따라서 Unicode로 작성된 파일을 읽고\u002F쓰는데 불편했지만, Python3에서는\n기본 UTF-8 encoding이 적용된다. Python3에서는 binary로 읽고\u002F쓰기 위해서는\n'rb', 'wb'로 mode를 명시해주어야한다.\u003C\u002Fp\u003E\n\u003Ch1 id=\"summary\"\u003E\u003Ca href=\"#summary\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ESummary\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp\u003EPython 3\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Ebytes\u003C\u002Fcode\u003E: sequences of 8-bit values.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003E: sequences of Unicode characters.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Ebytes\u003C\u002Fcode\u003E != \u003Ccode\u003Estr\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EPython 2\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003E contains sequences of 8-bit values.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eunicode\u003C\u002Fcode\u003E contains sequences of Unicode characters.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Estr\u003C\u002Fcode\u003E == \u003Ccode\u003Eunicode\u003C\u002Fcode\u003E if the \u003Ccode\u003Estr\u003C\u002Fcode\u003E only contains 7-bit ASCII characters.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EBinary data to\u002Ffrom a file: binary mode ('rb' or 'wb').\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1 id=\"reference\"\u003E\u003Ca href=\"#reference\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EReference\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdocs.python.org\u002F3\u002Fhowto\u002Funicode.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Epython.org\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003EEffective Python\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n"},"all":{"edges":[{"node":{"path":"\u002Fblog\u002Fpython-bytes-str","title":"(Python3) Sequences of Characters"},"next":{"path":"\u002Fblog\u002Finitial-post"}},{"node":{"path":"\u002Fblog\u002Finitial-post","title":"Initial Post"},"next":null}]}},"context":{}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.68cc814d.js" defer></script><script src="/assets/js/page--src--templates--blog-vue.2d008bb1.js" defer></script>
  </body>
</html>
